# Cache Aside Pattern

Cache Aside Pattern是一种保持缓存(和数据库的)一致性的一种模式，分为读和写两方面。

#### 读数据
1. 从缓存中读取数据
2. 如果从缓存中没有读到数据，则从数据库中读取数据
3. 将数据库中的数据写到缓存中

#### 写数据
1. 更新数据库中的数据
2. 删除缓存中的数据

之所以删除而非更新缓存，一是因为更新缓存较为复杂成本较高，二是可能造成数据不一致的问题。  
假如是更新缓存而非删除缓存，考虑以下场景:   
请求A将数据更新为50，请求B将数据更新为60，请求A先于请求B发生。
1. 请求A更新了数据库的数据为50
2. 请求B更新了数据库的数据为60
3. 请求B更新缓存为60
4. 请求A更新缓存为50  

至此，数据库中的值为60，而缓存中数据为50，造成数据不一致的问题。

而对于对步骤1和2的顺序，部分文章存在不同意见，认为应删除缓存后写数据库。事实上两种顺序都不能完全避免缓存不一致的产生，而笔者经过比较，认为上述顺序较为合适，原因见下文。

假如存在这样一个系统，数据库有主从架构，数据库之上有一层缓存。当前数据为40，请求A将数据更新为50，请求B为读请求。  
a. 假设先更新数据库后删除缓存  
会造成数据不一致的第一种场景为(主从延迟导致的不一致):  
1. 请求A更新主库的数据为50
2. 请求A删除缓存中的数据，这时主从同步尚未完成
3. 请求B从缓存中未读取到数据，读取从库的数据为40
4. 请求B将数据40写入缓存
5. 数据库主从同步完成

至此，数据库中的值为50，缓存中数据为40，造成数据不一致。

第二种场景为(操作失败导致的不一致):  
1. 请求A更新数据库的数据为50
2. 请求A删除缓存失败

至此，数据库中的值为50，缓存中数据为40，造成数据不一致。

b. 假设是先删除缓存后更新数据库  
会造成不一致的第一种场景为(操作成功但是由于并发导致的不一致):   
1. 请求A删除缓存
2. 请求B从缓存中未读取到数据，读取数据库数据为40
3. 请求B将数据40写入缓存
4. 请求A更新数据库数据为50

至此，数据库中数据为50，缓存中数据为40，造成数据不一致。

第二种场景为(主从延迟导致的不一致): 
这个同先更新数据库后删除缓存一样，无法避免读到旧数据的问题。

由此来看，主从延迟导致的不一致，是一个单独的问题，无法由读取顺序来避免。而数据库操作失败导致的不一致，则可以通过订阅bin log异步更新缓存来解决。
并且从概率上来看，先删除缓存后更新数据库，由于并发导致不一致从概率上来说较高，并且先删除缓存较小可能会导致缓存击穿的问题。因此笔者认为Cache Aside Pattern的顺序较为合适。

对先删缓存后写数据库，并发导致不一致的场景，实际也是有解决方案的。可以将请求放到内存队列中串行执行。当一个写请求过来，将其经过hash后放到对应内存队列中，
当读请求过来时，如果发现缓存不存在，且内存队列存在未完成的写请求，则也加入内存队列中，等待写请求完成后再执行。这里会产生读请求等待事件过长、积压请求等问题，需要额外的解决方案，暂不赘述。
